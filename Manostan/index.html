<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Sentence Map</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Google Fonts: Niramit & Xanh Mono -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Niramit:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;1,200;1,300;1,400;1,500;1,600;1,700&family=Xanh+Mono:ital@0;1&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Niramit', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        #sentence-box {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 900px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            font-family: 'Niramit', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            transition: all 0.3s ease;
        }
        
        #sentence-text {
            font-size: 25px;
            line-height: 1.8;
            margin-bottom: 12px;
            color: #333;
            min-height: 80px;
        }
        
        #coords-text {
            font-size: 13px;
            color: #666;
            margin-top: 10px;
            font-family: 'Xanh Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
        
        .loading {
            color: #999;
            font-style: italic;
        }
        
        .error {
            color: #d32f2f;
        }
        
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            z-index: 999;
            pointer-events: none;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
        }
        
        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        @media (max-width: 768px) {
            #sentence-box {
                left: 10px;
                right: 10px;
                padding: 15px;
            }
            
            #sentence-text {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div id="crosshair"></div>
    
    <div id="sentence-box">
        <div id="sentence-text" class="loading">Loading map...</div>
        <div id="coords-text">üìç <span id="coords">-</span></div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Initial center (Siam, Bangkok)
        const INITIAL_CENTER = [13.74437, 100.53340];
        const INITIAL_ZOOM = 17;
        
        // Fallback names
        const fallbackNames = [
            "‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ",
            "‡∏ô‡∏µ‡πâ",
            "‡∏£‡πâ‡∏≤‡∏ô‡∏ô‡∏µ‡πâ",
            "‡∏ï‡∏∂‡∏Å‡∏ô‡∏µ‡πâ",
            "‡πÄ‡∏™‡πâ‡∏ô",
            "‡∏¢‡πà‡∏≤‡∏ô",
        ];
        
        // Loading messages
        const loadingMessages = [
            "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏î‡∏π‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏¥‡∏î‡∏ó‡∏µ‡πà‡∏Ñ‡∏ô‡πÄ‡∏Ñ‡∏¢‡∏ó‡∏¥‡πâ‡∏á‡πÑ‡∏ß‡πâ‡πÅ‡∏ñ‡∏ß‡∏ô‡∏µ‡πâ...",
            "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏´‡∏≤‡∏Ñ‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏£‡∏á‡∏à‡∏≥‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏ñ‡∏ß‡∏ô‡∏µ‡πâ...",
            "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏∑‡∏ö‡∏´‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏¥‡∏î‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡∏Ñ‡∏ô‡πÄ‡∏Ñ‡∏¢‡∏ô‡∏∂‡∏Å‡∏ñ‡∏∂‡∏á...",
            "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ô‡∏∂‡∏Å‡∏ñ‡∏∂‡∏á‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡πÄ‡∏î‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤...",
            "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏ô‡πÉ‡∏à‡∏ó‡∏µ‡πà‡πÉ‡∏Ñ‡∏£‡πÄ‡∏Ñ‡∏¢‡∏ó‡∏¥‡πâ‡∏á‡πÑ‡∏ß‡πâ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ...",
            "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏¥‡∏î‡∏ó‡∏µ‡πà‡∏•‡∏≠‡∏¢‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÅ‡∏ñ‡∏ß‡∏ô‡∏µ‡πâ...",
        ];
        
        // Sentence templates
        const sentenceTemplates = [
            (n1, n2, n3, n4) => `‡πÉ‡∏ô‡∏´‡∏•‡∏≤‡∏¢ ‡πÜ ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏â‡∏±‡∏ô‡∏°‡∏±‡∏Å‡∏à‡∏∞‡πÄ‡∏î‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô${n1} ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏¥‡∏î‡∏Å‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏à‡∏£‡∏¥‡∏á ‡πÜ ‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏£‡∏≤‡∏°‡∏≤‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà`,
            (n1, n2, n3, n4) => `‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤‡πÅ‡∏ñ‡∏ß${n1} ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏£‡∏á‡∏à‡∏≥‡πÄ‡∏Å‡πà‡∏≤‡πÜ ‡∏Å‡πá‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÄ‡∏™‡∏°‡∏≠ ‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Ñ‡∏¥‡∏î‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡∏ó‡∏µ‡πà${n2} ‡∏ó‡∏µ‡πà‡∏û‡∏•‡∏≤‡∏î‡πÑ‡∏õ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡∏•‡πà‡∏≤`,
            (n1, n2, n3, n4) => `‡∏°‡∏µ‡∏ö‡∏≤‡∏á‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏Ñ‡∏¥‡∏î‡∏ñ‡∏∂‡∏á${n1} ‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏•‡∏≠‡∏î‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏¢‡∏¥‡∏ô‡∏ä‡∏∑‡πà‡∏≠${n2} ‡∏Ç‡∏µ‡πâ‡∏ô‡∏°‡∏≤`,
            (n1, n2, n3, n4) => `‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤‡πÅ‡∏ñ‡∏ß${n2} ‡∏°‡∏≤‡∏à‡∏∞ 20 ‡∏õ‡∏µ‡πÅ‡∏•‡πâ‡∏ß ‡∏Ñ‡∏¥‡∏î‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏°‡∏≤‡∏≠‡∏∞‡πÑ‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏õ‡∏ö‡πâ‡∏≤‡∏á‡∏°‡∏±‡πâ‡∏¢`,
            (n1, n2, n3, n4) => `14 ‡∏õ‡∏µ‡πÅ‡∏•‡πâ‡∏ß‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤‡πÅ‡∏ñ‡∏ß${n1} ‡∏´‡∏ß‡∏±‡∏á‡∏ß‡πà‡∏≤‡∏ñ‡πâ‡∏≤‡πÑ‡∏õ‡∏ó‡∏µ‡πà${n2} ‡∏´‡∏•‡∏≤‡∏¢ ‡πÜ ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏à‡∏∞‡∏¢‡∏±‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏ô‡∏∞`,
            (n1, n2, n3, n4) => `‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏ä‡πâ‡∏≤‡πÅ‡∏°‡πà‡∏ù‡∏≤‡∏Å‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß${n2} ‡πÅ‡∏ï‡πà‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏Å‡πá‡∏•‡∏∑‡∏°‡∏≠‡∏¢‡∏π‡πà‡∏î‡∏µ`,
            (n1, n2, n3, n4) => `‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏ï‡∏≠‡∏ô‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏ñ‡∏ß‡∏ô‡∏µ‡πâ ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ä‡πâ‡∏≤‡∏à‡∏∞‡∏ä‡∏≠‡∏ö‡∏°‡∏≠‡∏á‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á ‡πÅ‡∏•‡∏∞‡∏°‡∏≠‡∏á‡∏î‡∏π${n1}‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏∏‡∏Å ‡πÜ ‡∏ß‡∏±‡∏ô`,
            (n1, n2, n3, n4) => `‡∏ï‡∏±‡πâ‡∏á‡πÉ‡∏à‡∏à‡∏∞‡∏°‡∏≤‡πÅ‡∏ñ‡∏ß${n4} ‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≠‡∏ö‡∏•‡∏∞ ‡πÅ‡∏ï‡πà‡∏Å‡πá‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏™‡∏±‡∏Å‡∏ó‡∏µ‡πÄ‡∏•‡∏¢`,
            (n1, n2, n3, n4) => `‡∏ó‡∏∏‡∏Å ‡πÜ ‡∏ß‡∏±‡∏ô‡∏ï‡∏≠‡∏ô‡∏Ç‡∏±‡∏ö‡∏£‡∏ñ‡∏ú‡πà‡∏≤‡∏ô${n2} ‡∏Å‡πá‡∏à‡∏∞‡∏ä‡∏≠‡∏ö‡πÅ‡∏ß‡∏∞${n1}‡∏≠‡∏¢‡∏π‡πà‡πÄ‡∏™‡∏°‡∏≠‡πÜ`,
            (n1, n2, n3, n4) => `‡πÄ‡∏´‡πâ‡∏≠! ‡πÅ‡∏ñ‡∏ß${n3}‡∏£‡∏ñ‡∏ï‡∏¥‡∏î‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏•‡∏¢`,
            (n1, n2, n3, n4) => `‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏ï‡∏≠‡∏ô‡πÄ‡∏¢‡πá‡∏ô‡πÜ ‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡∏≠‡∏≤‡∏°‡πà‡∏≤‡∏ä‡∏≠‡∏ö‡∏°‡∏≤‡πÄ‡∏î‡∏¥‡∏ô‡πÄ‡∏•‡πà‡∏ô‡πÅ‡∏ñ‡∏ß${n1}‡πÅ‡∏ï‡πà‡∏´‡∏•‡∏±‡∏á‡πÜ ‡∏Å‡πá‡πÑ‡∏°‡πà‡∏Ñ‡πà‡∏≠‡∏¢‡πÄ‡∏´‡πá‡∏ô‡πÅ‡∏Å‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà‡πÅ‡∏•‡πâ‡∏ß`,
            (n1, n2, n3, n4) => `‡∏û‡∏≠‡∏°‡∏≤‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤‡πÅ‡∏ñ‡∏ß${n3}‡∏Å‡πá‡∏à‡∏∞‡∏ô‡∏∂‡∏Å‡∏ñ‡∏∂‡∏á‡πÄ‡∏£‡∏≤‡∏™‡∏°‡∏±‡∏¢‡∏Å‡πà‡∏≠‡∏ô‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏•‡∏¢ ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ò‡∏≠‡∏ó‡∏≥‡∏Å‡∏≤‡πÅ‡∏ü‡∏´‡∏•‡πà‡∏ô‡∏ó‡∏µ‡πà${n4}`,
            (n1, n2, n3, n4) => `‡πÄ‡∏Ñ‡∏¢‡πÄ‡∏Å‡πá‡∏ö‡∏•‡∏π‡∏Å‡πÅ‡∏°‡∏ß‡∏à‡∏≤‡∏Å‡πÅ‡∏ñ‡∏ß${n1} ‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡∏°‡∏±‡∏ô‡∏¢‡∏±‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡πá‡∏Å ‡πÜ ‡∏≠‡∏¢‡∏π‡πà‡πÄ‡∏•‡∏¢`,
            (n1, n2, n3, n4) => `‡∏ß‡∏±‡∏ô‡∏ô‡∏±‡πâ‡∏ô‡∏Ñ‡∏¥‡∏î‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÑ‡∏õ${n1} ‡πÅ‡∏ï‡πà‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ó‡∏µ‡πà${n2} ‡πÅ‡∏ï‡πà‡∏Å‡πá‡∏≠‡∏î‡∏Ñ‡∏¥‡∏î‡∏ñ‡∏∂‡∏á${n3}‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ`,
            (n1, n2, n3, n4) => `‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏î‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô${n1}‡∏ó‡∏µ‡πÑ‡∏£ ‡πÉ‡∏à‡∏°‡∏±‡∏ô‡∏ä‡∏≠‡∏ö‡∏ä‡πâ‡∏≤‡∏•‡∏á‡∏ó‡∏∏‡∏Å‡∏ó‡∏µ`,
            (n1, n2, n3, n4) => `‡πÅ‡∏ñ‡∏ß${n2}‡∏¢‡∏±‡∏á‡∏î‡∏π‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏•‡∏¢ ‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏Ñ‡πà‡∏Ñ‡∏¥‡∏î‡πÑ‡∏õ‡πÄ‡∏≠‡∏á‡∏ô‡∏∞`,
            (n1, n2, n3, n4) => `‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏™‡∏á‡πÅ‡∏î‡∏î‡∏ï‡∏£‡∏á${n1}‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏ô‡∏∂‡∏Å‡∏ñ‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏ô‡∏±‡πâ‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡πÄ‡∏â‡∏¢ ‡πÜ`,
            (n1, n2, n3, n4) => `‡πÄ‡∏Ñ‡∏¢‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏Å‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏ó‡∏µ‡πà${n2}‡∏≠‡∏µ‡∏Å ‡πÅ‡∏ï‡πà‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏Å‡πá‡∏°‡∏≤‡∏≠‡∏¢‡∏π‡πà‡∏î‡∏µ`,
            (n1, n2, n3, n4) => `‡πÅ‡∏Ñ‡πà‡πÑ‡∏î‡πâ‡∏¢‡∏¥‡∏ô‡∏ä‡∏∑‡πà‡∏≠${n3} ‡∏Å‡πá‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏ñ‡∏π‡∏Å‡∏î‡∏∂‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ó‡∏µ‡πà${n1}‡πÄ‡∏•‡∏¢`,
            (n1, n2, n3, n4) => `‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏ó‡∏≥‡πÑ‡∏°‡∏û‡∏≠‡∏°‡∏≤‡πÅ‡∏ñ‡∏ß${n1}‡πÅ‡∏•‡πâ‡∏ß ‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡∏≤‡∏Å‡∏î‡∏π‡πÄ‡∏á‡∏µ‡∏¢‡∏ö‡∏•‡∏á`,
            (n1, n2, n3, n4) => `‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏â‡∏±‡∏ô‡πÄ‡∏Ñ‡∏¢‡∏£‡∏≠‡πÉ‡∏Ñ‡∏£‡πÄ‡∏Ç‡∏≤‡∏ï‡∏£‡∏á${n2} ‡πÄ‡∏î‡∏µ‡πã‡∏¢‡∏ß‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏à‡∏≠‡∏Å‡∏±‡∏ô‡∏≠‡∏µ‡∏Å‡πÄ‡∏•‡∏¢`,
            (n1, n2, n3, n4) => `‡πÅ‡∏ñ‡∏ß${n2}‡∏Ñ‡∏ô‡πÄ‡∏¢‡∏≠‡∏∞‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏° ‡πÅ‡∏ï‡πà‡∏Å‡∏•‡∏±‡∏ö‡∏£‡∏π‡πâ‡∏™‡∏∂‡∏Å‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏Ñ‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß`,
            (n1, n2, n3, n4) => `‡∏ñ‡πâ‡∏≤‡∏ï‡∏≠‡∏ô‡∏ô‡∏±‡πâ‡∏ô‡πÑ‡∏°‡πà‡πÑ‡∏õ‡∏ó‡∏µ‡πà${n1} ‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ï‡πà‡∏≤‡∏á‡πÑ‡∏õ‡πÑ‡∏´‡∏°‡∏ô‡∏∞`,
            (n1, n2, n3, n4) => `‡πÄ‡∏Ñ‡∏¢‡πÄ‡∏î‡∏¥‡∏ô‡∏´‡∏•‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏ñ‡∏ß${n3} ‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏•‡∏±‡∏ö‡∏£‡∏π‡πâ‡∏™‡∏∂‡∏Å‡∏™‡∏ö‡∏≤‡∏¢‡πÉ‡∏à‡πÅ‡∏õ‡∏•‡∏Å ‡πÜ`,
            (n1, n2, n3, n4) => `‡∏â‡∏±‡∏ô‡∏à‡∏≥‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏•‡∏°‡∏ï‡∏£‡∏á${n1}‡πÑ‡∏î‡πâ‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡∏à‡∏∞‡∏à‡∏≥‡πÑ‡∏î‡πâ‡∏≠‡∏µ‡∏Å`,
            (n1, n2, n3, n4) => `‡∏ö‡∏≤‡∏á‡∏ó‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏£‡∏á‡∏à‡∏≥‡∏Å‡πá‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡∏±‡∏ß ‡πÅ‡∏ï‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏£‡∏á${n1}`,
            (n1, n2, n3, n4) => `‡πÄ‡∏Ñ‡∏¢‡∏Ñ‡∏¥‡∏î‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏´‡∏ô‡∏µ‡πÑ‡∏õ‡πÉ‡∏´‡πâ‡πÑ‡∏Å‡∏•‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡πÅ‡∏ï‡πà‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏Å‡πá‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏ó‡∏µ‡πà${n1}`,
            (n1, n2, n3, n4) => `‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏ä‡∏≠‡∏ö‡πÅ‡∏ß‡∏∞${n2}‡∏ö‡πà‡∏≠‡∏¢ ‡πÜ ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏°‡πà‡∏Å‡∏•‡πâ‡∏≤‡πÅ‡∏ß‡∏∞‡πÅ‡∏•‡πâ‡∏ß`,    
            (n1, n2, n3, n4) => `‡πÄ‡∏Ñ‡∏¢‡∏°‡∏≤‡∏´‡∏•‡∏ö‡∏ù‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏£‡∏á${n1} ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏¥‡∏î‡∏ß‡πà‡∏≤‡∏ñ‡πâ‡∏≤‡∏ù‡∏ô‡πÑ‡∏°‡πà‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡πá‡∏Ñ‡∏á‡∏î‡∏µ`,
            (n1, n2, n3, n4) => `‡πÅ‡∏ñ‡∏ß${n3}‡∏°‡∏µ‡∏£‡πâ‡∏≤‡∏ô‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏ï‡πá‡∏°‡πÑ‡∏õ‡∏´‡∏°‡∏î ‡πÅ‡∏ï‡πà‡πÉ‡∏ô‡∏´‡∏±‡∏ß‡∏â‡∏±‡∏ô‡∏¢‡∏±‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡πÄ‡∏î‡∏¥‡∏°`,
            (n1, n2, n3, n4) => `‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô${n2} ‡∏â‡∏±‡∏ô‡∏à‡∏∞‡∏ô‡∏∂‡∏Å‡∏ñ‡∏∂‡∏á‡πÄ‡∏Ç‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡πÄ‡∏î‡∏¥‡∏ô‡∏Ç‡πâ‡∏≤‡∏á ‡πÜ`,
            (n1, n2, n3, n4) => `‡πÄ‡∏Ñ‡∏¢‡∏Ñ‡∏¥‡∏î‡∏ß‡πà‡∏≤‡∏ó‡∏µ‡πà${n2}‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô ‡πÅ‡∏ï‡πà‡∏Å‡∏•‡∏±‡∏ö‡∏Å‡∏•‡∏≤‡∏¢‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏∏‡∏î‡∏à‡∏ö`,
            (n1, n2, n3, n4) => `‡∏ö‡∏≤‡∏á‡∏ß‡∏±‡∏ô‡∏Å‡πá‡πÅ‡∏Ñ‡πà‡∏≠‡∏¢‡∏≤‡∏Å‡πÄ‡∏î‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô${n1}‡πÄ‡∏â‡∏¢ ‡πÜ ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏∞‡πÑ‡∏£`,
            (n1, n2, n3, n4) => `‡∏ö‡∏≤‡∏á‡∏ó‡∏µ‡∏â‡∏±‡∏ô‡∏Å‡πá‡πÅ‡∏Ñ‡πà‡∏≠‡∏¢‡∏≤‡∏Å‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏µ‡πà${n2}`,
            (n1, n2, n3, n4) => `‡∏û‡∏≠‡∏°‡∏≤‡πÅ‡∏ñ‡∏ß${n3}‡πÅ‡∏•‡πâ‡∏ß‡∏ñ‡∏∂‡∏á‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤ ‡∏ö‡∏≤‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏±‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ`,
            (n1, n2, n3, n4) => `‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏ú‡πà‡∏≤‡∏ô${n2}‡πÅ‡∏•‡πâ‡∏ß‡∏ô‡∏∂‡∏Å‡∏ñ‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏µ‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏ô‡∏µ‡πâ`,
            (n1, n2, n3, n4) => `‡πÅ‡∏ñ‡∏ß${n3}‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏î‡∏π‡∏™‡∏î‡πÉ‡∏™ ‡πÅ‡∏ï‡πà‡∏â‡∏±‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏°‡πà‡∏Ñ‡πà‡∏≠‡∏¢‡∏™‡∏î‡πÉ‡∏™‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà`,
            (n1, n2, n3, n4) => `‡∏â‡∏±‡∏ô‡πÄ‡∏Ñ‡∏¢‡∏Ñ‡∏¥‡∏î‡∏ß‡πà‡∏≤‡∏ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ‡πÑ‡∏õ${n1}‡∏à‡∏∞‡∏•‡∏∑‡∏°‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏î‡πâ ‡πÅ‡∏ï‡πà‡∏Å‡πá‡πÑ‡∏°‡πà‡∏•‡∏∑‡∏°`,
            (n1, n2, n3, n4) => `‡∏ú‡πà‡∏≤‡∏ô${n3}‡πÅ‡∏•‡πâ‡∏ß‡∏ô‡∏∂‡∏Å‡∏ñ‡∏∂‡∏á‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏±‡∏ô‡∏ï‡∏•‡∏≠‡∏î`,
            (n1, n2, n3, n4) => `‡∏û‡∏≠‡∏°‡∏≤‡πÅ‡∏ñ‡∏ß${n3}‡πÅ‡∏•‡πâ‡∏ß‡∏ñ‡∏∂‡∏á‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤ ‡πÄ‡∏£‡∏≤‡πÇ‡∏ï‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏¢‡∏≠‡∏∞‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô`,
            (n1, n2, n3, n4) => `‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏ú‡πà‡∏≤‡∏ô${n2}‡πÅ‡∏•‡πâ‡∏ß‡∏£‡∏π‡πâ‡∏™‡∏∂‡∏Å‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÉ‡∏à‡∏°‡∏±‡∏ô‡∏´‡∏≤‡∏¢‡πÑ‡∏õ‡∏ô‡∏¥‡∏î‡∏ô‡∏∂‡∏á`,
            (n1, n2, n3, n4) => `‡∏û‡∏≠‡∏ú‡πà‡∏≤‡∏ô${n3}‡∏Å‡πá‡∏à‡∏∞‡∏ô‡∏∂‡∏Å‡∏ñ‡∏∂‡∏á‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÄ‡∏•‡πá‡∏Å ‡πÜ ‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å`,
            (n1, n2, n3, n4) => `‡πÅ‡∏ñ‡∏ß${n1}‡∏¢‡∏±‡∏á‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏° ‡πÅ‡∏ï‡πà‡∏û‡∏≠‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡πÑ‡∏õ‡∏ó‡∏≤‡∏á${n2} ‡∏â‡∏±‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡∏£‡∏π‡πâ‡∏™‡∏∂‡∏Å‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏´‡∏•‡∏∏‡∏î‡πÑ‡∏õ‡∏≠‡∏µ‡∏Å‡πÇ‡∏•‡∏Å`,
            (n1, n2, n3, n4) => `‡πÅ‡∏ñ‡∏ß${n1}‡∏°‡∏µ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏£‡∏ñ‡∏î‡∏±‡∏á‡∏°‡∏≤‡∏Å`,
            (n1, n2, n3, n4) => `‡πÄ‡∏Ñ‡∏¢‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏Å‡∏±‡∏ô‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏°‡∏≤‡∏ó‡∏µ‡πà${n1}‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏±‡∏ô ‡πÅ‡∏ï‡πà‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏Å‡πá‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏≤‡∏Ñ‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß`,
            (n1, n2, n3, n4) => `‡∏â‡∏±‡∏ô‡πÄ‡∏Ñ‡∏¢‡∏ó‡∏≥‡∏Ç‡∏≠‡∏á‡∏´‡∏≤‡∏¢‡∏ó‡∏µ‡πà${n1} ‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏õ‡πÄ‡∏à‡∏≠‡∏°‡∏±‡∏ô‡∏≠‡∏µ‡∏Å‡∏ó‡∏µ‡∏ó‡∏µ‡πà${n2} ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï‡∏ä‡∏≠‡∏ö‡πÄ‡∏•‡πà‡∏ô‡∏ï‡∏•‡∏Å`,
            (n1, n2, n3, n4) => `‡∏ö‡∏≤‡∏á‡∏ó‡∏µ‡∏Å‡πá‡∏¢‡∏≤‡∏Å‡∏¢‡πâ‡∏≤‡∏¢‡∏ö‡πâ‡∏≤‡∏ô‡∏°‡∏≤‡πÅ‡∏ñ‡∏ß${n1} ‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï‡∏à‡∏∞‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô`,
            (n1, n2, n3, n4) => `‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏´‡πá‡∏ô${n3} ‡∏â‡∏±‡∏ô‡∏à‡∏∞‡∏ô‡∏∂‡∏Å‡∏ñ‡∏∂‡∏á${n1}‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•`,
            (n1, n2, n3, n4) => `‡∏ö‡∏≤‡∏á‡∏ó‡∏µ${n1}‡∏Å‡πá‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏õ‡∏´‡∏£‡∏≠‡∏Å ‡πÅ‡∏Ñ‡πà‡∏â‡∏±‡∏ô‡πÄ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô`,
            (n1, n2, n3, n4) => `‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏ú‡πà‡∏≤‡∏ô${n1}‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏¥‡∏î‡∏ß‡πà‡∏≤ ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÑ‡∏î‡πâ‡πÄ‡∏à‡∏≠‡∏Å‡∏±‡∏ô‡∏≠‡∏µ‡∏Å‡πÑ‡∏´‡∏°`,
            (n1, n2, n3, n4) => `‡∏û‡∏≠‡πÄ‡∏´‡πá‡∏ô${n1}‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÉ‡∏ô‡∏£‡∏≠‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏õ‡∏µ ‡∏Å‡πá‡∏£‡∏π‡πâ‡πÄ‡∏•‡∏¢‡∏ß‡πà‡∏≤‡∏ö‡∏≤‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏±‡∏ô‡πÑ‡∏°‡πà‡∏´‡∏≤‡∏¢‡πÑ‡∏õ‡πÑ‡∏´‡∏ô`,
        ];
        
        // Initialize map
        const map = L.map('map').setView(INITIAL_CENTER, INITIAL_ZOOM);
        
        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a>',
            maxZoom: 19
        }).addTo(map);
        
        // Get place names from Nominatim API
        async function getPlaceNames(lat, lng) {
            try {
                const names = [];
                const seenNames = new Set();
                
                // Helper function to calculate distance using Haversine formula
                function getDistance(lat1, lon1, lat2, lon2) {
                    const R = 6371e3; // Earth radius in meters
                    const œÜ1 = lat1 * Math.PI / 180;
                    const œÜ2 = lat2 * Math.PI / 180;
                    const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
                    const ŒîŒª = (lon2 - lon1) * Math.PI / 180;
                    
                    const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                            Math.cos(œÜ1) * Math.cos(œÜ2) *
                            Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                    
                    return R * c; // Distance in meters
                }
                
                // Helper function to add unique names with filtering
                function addName(name) {
                    if (!name || !name.trim() || seenNames.has(name.trim()) || names.length >= 4) {
                        return false;
                    }
                    
                    const trimmed = name.trim();
                    
                    // Filter out administrative names
                    const adminPatterns = [
                        /^‡πÄ‡∏Ç‡∏ï/, /^‡πÅ‡∏Ç‡∏ß‡∏á/,
                        /district$/i, /subdistrict$/i, /suburb$/i, /neighbourhood$/i,
                        /Bangkok Metropolitan/i, /‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û‡∏°‡∏´‡∏≤‡∏ô‡∏Ñ‡∏£/,
                        /^Thailand$/i, /^‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡πÑ‡∏ó‡∏¢$/,
                        /^Bangkok$/i, /^‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û$/
                    ];
                    
                    if (adminPatterns.some(pattern => pattern.test(trimmed))) {
                        return false;
                    }
                    
                    // Filter out generic/meaningless names
                    if (trimmed.length < 2 || trimmed.length > 100) {
                        return false;
                    }
                    
                    // Filter out pure numbers or address numbers
                    if (/^\d+$/.test(trimmed) || /^[0-9\/\-]+$/.test(trimmed)) {
                        return false;
                    }
                    
                    names.push(trimmed);
                    seenNames.add(trimmed);
                    return true;
                }
                
                // Helper function to add timeout to fetch
                function fetchWithTimeout(url, options = {}, timeout = 2000) {
                    return Promise.race([
                        fetch(url, options),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Timeout')), timeout)
                        )
                    ]);
                }
                
                // Run all API calls in parallel with timeouts
                const reverseUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=th`;
                const nearbyUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${lat},${lng}&limit=15&radius=300&addressdetails=1&accept-language=th`;
                const overpassUrl = 'https://overpass-api.de/api/interpreter';
                const overpassQuery = `[out:json][timeout:3];(way["highway"]["name"](around:300,${lat},${lng});node["shop"]["name"](around:300,${lat},${lng});way["shop"]["name"](around:300,${lat},${lng});node["amenity"~"restaurant|cafe|bar|fast_food|bank|hospital|school|university|temple|place_of_worship"]["name"](around:300,${lat},${lng});way["amenity"~"restaurant|cafe|bar|fast_food|bank|hospital|school|university|temple|place_of_worship"]["name"](around:300,${lat},${lng});way["building"]["name"](around:300,${lat},${lng});node["tourism"]["name"](around:300,${lat},${lng});way["tourism"]["name"](around:300,${lat},${lng});node["historic"]["name"](around:300,${lat},${lng}););out center;`;
                
                // Start all API calls in parallel with shorter timeouts
                const [reverseResponse, nearbyResponse, overpassResponse] = await Promise.allSettled([
                    fetchWithTimeout(reverseUrl, {
                        headers: {
                            'User-Agent': 'InteractiveSentenceMap/1.0'
                        }
                    }, 2000),
                    fetchWithTimeout(nearbyUrl, {
                        headers: {
                            'User-Agent': 'InteractiveSentenceMap/1.0'
                        }
                    }, 2000),
                    fetchWithTimeout(overpassUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'User-Agent': 'InteractiveSentenceMap/1.0'
                        },
                        body: `data=${encodeURIComponent(overpassQuery)}`
                    }, 2500)
                ]);
                
                // Step 1: Process reverse geocoding results
                if (reverseResponse.status === 'fulfilled' && reverseResponse.value.ok) {
                    try {
                        const reverseData = await reverseResponse.value.json();
                        
                        // Prioritize actual POI names (building names, shop names, etc.)
                        const poiClasses = ['building', 'amenity', 'shop', 'tourism', 'historic', 'leisure', 'public_transport', 'waterway'];
                        if (reverseData.name && reverseData.class && poiClasses.includes(reverseData.class)) {
                            // This is a named POI - use its actual name first
                            addName(reverseData.name);
                        }
                        
                        // Then extract specific address fields
                        if (reverseData.address) {
                            const addr = reverseData.address;
                            
                            // Priority: road > specific place names
                            if (addr.road || addr.street) {
                                addName(addr.road || addr.street);
                            }
                        }
                        
                        // If we still need more names and haven't used the name yet
                        if (names.length < 4 && reverseData.name && 
                            reverseData.class !== 'boundary' && reverseData.class !== 'place' &&
                            !names.includes(reverseData.name)) {
                            addName(reverseData.name);
                        }
                    } catch (e) {
                        console.log('Reverse geocoding processing failed:', e);
                    }
                }
                
                // Early return if we have enough names
                if (names.length >= 4) {
                    return names.slice(0, 4);
                }
                
                // Step 2: Process nearby places search results
                if (nearbyResponse.status === 'fulfilled' && nearbyResponse.value.ok) {
                    try {
                        const nearbyData = await nearbyResponse.value.json();
                        
                        for (const place of nearbyData) {
                            if (names.length >= 4) break;
                            
                            // Skip if type is administrative
                            if (place.type && /district|suburb|neighbourhood|city|state|county/.test(place.type)) {
                                continue;
                            }
                            
                            // Skip if class indicates administrative boundary
                            if (place.class && /boundary|place/.test(place.class)) {
                                continue;
                            }
                            
                            // Prioritize actual place names for POIs
                            const poiClasses = ['building', 'amenity', 'shop', 'tourism', 'historic', 'leisure'];
                            if (place.name && place.class && poiClasses.includes(place.class)) {
                                addName(place.name);
                                continue; // Move to next place after adding POI name
                            }
                            
                            // For roads, extract from address
                            if (place.address && (place.address.road || place.address.street)) {
                                addName(place.address.road || place.address.street);
                            } else if (place.name && place.class === 'highway') {
                                // Highway name
                                addName(place.name);
                            }
                        }
                    } catch (e) {
                        console.log('Nearby search processing failed:', e);
                    }
                }
                
                // Early return if we have enough names
                if (names.length >= 4) {
                    return names.slice(0, 4);
                }
                
                // Step 3: Process Overpass API query results (only if we still need names)
                if (overpassResponse.status === 'fulfilled' && overpassResponse.value.ok) {
                    try {
                        const overpassData = await overpassResponse.value.json();
                        if (overpassData.elements) {
                            // Calculate distances and assign priorities
                            const elementsWithScore = overpassData.elements.map(el => {
                                // Get coordinates (use center for ways/relations)
                                const elLat = el.lat || (el.center && el.center.lat);
                                const elLon = el.lon || (el.center && el.center.lon);
                                
                                if (!elLat || !elLon) return null;
                                
                                const distance = getDistance(lat, lng, elLat, elLon);
                                
                                // Type priority: roads=1, shops=2, restaurants=3, buildings=4, others=5
                                let typePriority = 5;
                                if (el.tags.highway) typePriority = 1;
                                else if (el.tags.shop) typePriority = 2;
                                else if (el.tags.amenity && /restaurant|cafe|bar|fast_food/.test(el.tags.amenity)) typePriority = 3;
                                else if (el.tags.building) typePriority = 4;
                                
                                // Combined score: type priority + normalized distance (lower is better)
                                // Weight: type priority * 100 + distance to prioritize type but consider distance
                                const score = typePriority * 100 + distance;
                                
                                return { element: el, distance, typePriority, score };
                            }).filter(item => item !== null);
                            
                            // Sort by combined score (lower = better)
                            elementsWithScore.sort((a, b) => a.score - b.score);
                            
                            // Extract names from sorted elements
                            for (const item of elementsWithScore) {
                                if (names.length >= 4) break;
                                
                                const element = item.element;
                                
                                // Skip if it has admin tags
                                if (element.tags.admin_level || element.tags.boundary) {
                                    continue;
                                }
                                
                                // Skip if place type indicates administrative area
                                if (element.tags.place && /suburb|neighbourhood|district|city|town/.test(element.tags.place)) {
                                    continue;
                                }
                                
                                // Prefer Thai name if available, otherwise use regular name
                                if (element.tags['name:th']) {
                                    addName(element.tags['name:th']);
                                } else if (element.tags.name) {
                                    addName(element.tags.name);
                                }
                            }
                        }
                    } catch (e) {
                        console.log('Overpass API processing failed:', e);
                    }
                }
                
                // Step 4: Fill with fallback names if still needed
                if (names.length < 4) {
                    for (const fallback of fallbackNames) {
                        if (!seenNames.has(fallback) && names.length < 4) {
                            names.push(fallback);
                            seenNames.add(fallback);
                        }
                    }
                }
                
                // Ensure we have exactly 4 names
                while (names.length < 4) {
                    const fallback = fallbackNames[names.length % fallbackNames.length];
                    if (!seenNames.has(fallback)) {
                        names.push(fallback);
                        seenNames.add(fallback);
                    } else {
                        names.push(fallback + ' ' + (names.length + 1));
                    }
                }
                
                return names.slice(0, 4);
            } catch (error) {
                console.error('Error getting place names:', error);
                return fallbackNames.slice(0, 4);
            }
        }
        
        // Generate sentence
        function makeSentence(names) {
            const template = sentenceTemplates[Math.floor(Math.random() * sentenceTemplates.length)];
            return template(names[0], names[1], names[2], names[3]);
        }
        
        // Update sentence display
        async function updateSentence(lat, lng) {
            const sentenceText = document.getElementById('sentence-text');
            const coordsSpan = document.getElementById('coords');
            
            // Update coordinates immediately
            coordsSpan.textContent = `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
            
            // Show loading state with random message
            const loadingMessage = loadingMessages[Math.floor(Math.random() * loadingMessages.length)];
            sentenceText.innerHTML = `<span class="loading">${loadingMessage}</span>`;
            sentenceText.classList.add('loading');
            
            try {
                // Get place names
                const names = await getPlaceNames(lat, lng);
                
                // Generate sentence
                const sentence = makeSentence(names);
                
                // Update display
                sentenceText.textContent = `"${sentence}"`;
                sentenceText.classList.remove('loading');
            } catch (error) {
                console.error('Error updating sentence:', error);
                sentenceText.innerHTML = '<span class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ</span>';
                sentenceText.classList.remove('loading');
            }
        }
        
        // Debounce function
        let updateTimeout = null;
        let lastUpdate = 0;
        const COOLDOWN = 1600; // 2 seconds
        
        // Handle map movement
        map.on('moveend', function() {
            const now = Date.now();
            if (now - lastUpdate < COOLDOWN) {
                return;
            }
            lastUpdate = now;
            
            // Clear any pending updates
            if (updateTimeout) {
                clearTimeout(updateTimeout);
            }
            
            // Debounce the update (reduced from 300ms to 150ms)
            updateTimeout = setTimeout(() => {
                const center = map.getCenter();
                updateSentence(center.lat, center.lng);
            }, 150);
        });
        
        // Initial sentence
        updateSentence(INITIAL_CENTER[0], INITIAL_CENTER[1]);
    </script>
</body>
</html>
